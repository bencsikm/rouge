
// This is a comment

(* Constructor
    
    Initialize variables 
    
*)
FUNCTION GainControl::GainControl
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
    
    // object pointers to the gainPhase. 
    thePhaseOf[PHASE_1]     := #GainPhase1.Status;
    thePhaseOf[PHASE_2]     := #GainPhase2.Status;
    thePhaseOf[PHASE_3]     := #GainPhase3.Status;
    
    theOLPhaseOf[PHASE_1]   := #OpenLoopPhase1.Status;
    theOLPhaseOf[PHASE_2]   := #OpenLoopPhase2.Status;
    theOLPhaseOf[PHASE_3]   := #OpenLoopPhase3.Status;
    
    flag_shotInProgress     := FALSE;
    flag_endOfShot          := FALSE;
    flag_phase2Initialized  := FALSE;
    
    resetManualStateMachine();
    resetAutoStateMachine();
    resetOutputs();
    
    OpenLoopPhase1.resetAutoActuals();
    OpenLoopPhase2.resetAutoActuals();
    OpenLoopPhase3.resetAutoActuals();
    
	ret_code := C_OK;
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL GainControl::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
    
    
    // Not enabled - the rest of the class is mostly ignored. 
    if isEnabled = 0 then
        resetManualStateMachine();
        resetAutoStateMachine();
        OpenLoopPhase1.resetAutoActuals();
        OpenLoopPhase2.resetAutoActuals();
        OpenLoopPhase3.resetAutoActuals();
        flag_phase2Initialized  := FALSE;
        state := READY;
        return;
    end_if;
    
    if isShotInProgress() then
    
        case controlMode of
        GAIN_MODE_REGULAR, 
        GAIN_MODE_MANUAL: 
            manualStateMachine();
        GAIN_MODE_AUTO: 
            autoStateMachine();
        end_case;
        
    else
        resetManualStateMachine();
        resetAutoStateMachine();
    end_if;


	state := READY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL GainControl::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
    
    if flag_endOfShot then
        flag_endOfShot := FALSE;
        
        if OpenLoopPhase1.openLoopSuccess() & OpenLoopPhase2.openLoopSuccess() then
            OLAT.initialize(MeltPressureBuffer.GetBuffer(0));
            OLAT.findSlope(PHASE_1);
            OLAT.findSlope(PHASE_2);
            OLAT.intersection();
            OLAT.setControlValue(cv1:=OpenLoopPhase1.getActualFeedForward(), cv2:=OpenLoopPhase2.getActualFeedForward());
            meltPressureMax := meltPressureMax.Read();
            OLAT.setMaxMeltPressure(maxMelt:= meltPressureMax);
            
            OLAT.calcProcessGain();
            OLAT.calcPIGain();

        end_if;

       
    end_if;
    
    
    if OLATValidate1.writeInProgress() then
        OLATValidate1.writeToFile();
    end_if;


	state := READY;

END_FUNCTION



(*****************************
*  General functions
*****************************)


FUNCTION GainControl::isShotInProgress
	VAR_OUTPUT
		OutParam 	: BOOL;
	END_VAR
    
    if IMPProfiler.CurStep > 0 then
        flag_shotInProgress := TRUE;
        OutParam := TRUE;
    else
        if flag_shotInProgress then
            flag_shotInProgress := FALSE;
            flag_endOfShot      := TRUE;
        end_if;
        OutParam := FALSE;
    end_if;
END_FUNCTION


FUNCTION GainControl::readLiveData
   
    // clients
    cycleTime                           := cycleTime.Read();
    screwTravel                         := screwTravel.Read();
    
    // set values
    liveValues[SWITCH_TYPE_TIME]        := cycleTime;
    liveValues[SWITCH_TYPE_TRAVEL]      := screwTravel;
    liveValues[SWITCH_TYPE_STEP]        := IMPProfiler.CurStep;
    liveValues[SWITCH_TYPE_PERCENT]     := IMPProfiler.PctOfStep.Read();

END_FUNCTION

FUNCTION GainControl::resetOutputs
    sumFeedForward(0);         
    setGainsFor(NIL); 
END_FUNCTION


FUNCTION GainControl::setGainsFor
	VAR_INPUT
		phase 	: ^void;
	END_VAR
    
    if phase <> NIL then
        Kp  := phase^$GainPhase.Kp;
        Ki  := phase^$GainPhase.Ki;
        Ki2 := phase^$GainPhase.Ki2;
        Kd  := phase^$GainPhase.Kd;
    else
        Kp  := thePhaseOf[PHASE_1]^$GainPhase.Kp;
        Ki  := thePhaseOf[PHASE_1]^$GainPhase.Ki;
        Ki2 := thePhaseOf[PHASE_1]^$GainPhase.Ki2;
        Kd  := thePhaseOf[PHASE_1]^$GainPhase.Kd;
    end_if;
    
    
END_FUNCTION

FUNCTION GainControl::sumFeedForward
	VAR_INPUT
		feedforward 	: DINT;
	END_VAR
    
    feedForwardOffset := feedForwardOffset.Read();
    
    CASE controlMode OF
    GAIN_MODE_REGULAR:
        FeedForwardOut := feedForwardOffset;
    GAIN_MODE_MANUAL,
    GAIN_MODE_AUTO:
        
        FeedForwardOut := feedforward + feedForwardOffset;

    else
        FeedForwardOut := feedForwardOffset;
    END_CASE;
    
END_FUNCTION

(*****************************
*  Manual functions
*****************************)

FUNCTION GainControl::manualStateMachine
    VAR
    	phase : ^GainPhase;
    END_VAR
    
    
    if currentPhase >= PHASE_3 then
        currentPhase := PHASE_3;
    end_if;

    phase := thePhaseOf[currentPhase]$^GainPhase;
    
    case manualState of
    GAIN_IDLE_STATE:  
        // spare state that is not being used. 
        manualState     := SET_GAIN_DATA_STATE;
        
    SET_GAIN_DATA_STATE: 
        
        if phase^.switchLimit() > 0 then
            setGainsFor(thePhaseOf[currentPhase]);
            sumFeedForward(phase^.startFeedForward);
            manualState     := WAIT_FOR_LIMIT;
        else
            currentPhase    += NEXT_PHASE;
        end_if;
        
        if currentPhase >= PHASE_3 then
            currentPhase    := PHASE_3;
            manualState     := BUMPLESS_STATE;
        end_if;
        
    WAIT_FOR_LIMIT: 
    
        readLiveData();
        if phase^.limitHasBeenReached(#liveValues[0], controlMode) then
            currentPhase    += NEXT_PHASE;
            manualState     := SET_GAIN_DATA_STATE;
            
        end_if;
        
    BUMPLESS_STATE:
        
        IMPProfiler.bumplessTransfer(to_real(FeedForwardOut), to_real(phase^.Kp), to_real(phase^.Kd));
        setGainsFor(thePhaseOf[PHASE_3]);
        sumFeedForward(0);
        manualState := FINAL_STATE;
    
    FINAL_STATE:
        
        // Wait for end of shot
        
    end_case;
    
END_FUNCTION


FUNCTION GainControl::resetManualStateMachine
    
    manualState     := SET_GAIN_DATA_STATE;
    currentPhase    := PHASE_1;
    
    // necessary? prob not
    GainPhase3.clearAllButGains();
    
    // moves timeLimit server into actual timelime
    // TODO
    GainPhase1.resetTimeLimit();
    GainPhase2.resetTimeLimit();
    GainPhase3.resetTimeLimit();
    
    resetOutputs();           

END_FUNCTION

(*****************************
*  Auto functions
*****************************)

FUNCTION GainControl::autoStateMachine
    VAR
    	phase : ^GainPhase;
    END_VAR
    
    
    if currentPhase >= LAST_PHASE then
        currentPhase := LAST_PHASE;
    end_if;

    //phase := theOLPhaseOf[currentPhase]$^GainPhase;
    phase$^void := theOLPhaseOf[currentPhase];
    
    case autoState of
    GAIN_IDLE_STATE:  
        // spare state that is not being used. 
        autoState := SET_GAIN_DATA_STATE;
    
    SET_GAIN_DATA_STATE:

        setGainsFor(theOLPhaseOf[currentPhase]);
        sumFeedForward(phase^.getActualFeedForward());
        
        autoState := WAIT_FOR_LIMIT;
        
    WAIT_FOR_LIMIT:
        readLiveData();
        // wait for limit to be reached
        if phase^.limitHasBeenReached(#liveValues[0], controlMode) then

            if phase^.whichLimitReached() = phase^.switchType then
                // success
                phase^.setEndIndex(liveValues[SWITCH_TYPE_TIME]);
                
                updateNextAutoPhase(currentPhase);
 
                currentPhase                    += NEXT_PHASE;
                autoState                       := SET_GAIN_DATA_STATE;
                
            elsif phase^.whichLimitReached() = SWITCH_TYPE_TIME then
                
                // try again
                if phase^.anotherAttemptIsAllowed() then
                    phase^.updateNextAttempt();
                    autoState := SET_GAIN_DATA_STATE; 
                else
                    // fail go to last phase
                    currentPhase    := LAST_PHASE;
                    
                end_if;
            end_if;
            
            if currentPhase >= LAST_PHASE then
                currentPhase    := LAST_PHASE;
                autoState       := BUMPLESS_STATE;
            end_if;
            
        end_if;

    BUMPLESS_STATE:
        
        IMPProfiler.bumplessTransfer(to_real(FeedForwardOut), to_real(phase^.Kp), to_real(phase^.Kd));
        setGainsFor(theOLPhaseOf[LAST_PHASE]);
        sumFeedForward(0);
        autoState := FINAL_STATE;
    
    FINAL_STATE:
        

        
    end_case;

END_FUNCTION


FUNCTION GainControl::resetAutoStateMachine
    
    autoState               := SET_GAIN_DATA_STATE;
    currentPhase            := PHASE_1;
    
    
    OpenLoopPhase1.resetAttemptCounter();
    OpenLoopPhase2.resetAttemptCounter();
    OpenLoopPhase3.resetAttemptCounter();
    
    OpenLoopPhase1.switchType := SWITCH_TYPE_PERCENT;
    OpenLoopPhase2.switchType := SWITCH_TYPE_PERCENT;
    
    
    resetOutputs();
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL GainControl::resetAuto::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	resetAuto := input;
    
    if resetAuto = 1 then
        resetAutoStateMachine();
        OpenLoopPhase1.resetAutoActuals();
        OpenLoopPhase2.resetAutoActuals();
        OpenLoopPhase3.resetAutoActuals();
        flag_phase2Initialized  := FALSE;
        resetAuto := 0;
    end_if;

    
	result := resetAuto;

END_FUNCTION





FUNCTION GainControl::updateNextAutoPhase
	VAR_INPUT
		currentPhaseNumber 	: DINT;
	END_VAR
    VAR
    	source      : ^GainPhase;
        destination : ^GainPhase;
    END_VAR
    
    if currentPhaseNumber >= LAST_PHASE - 1 then
        return;
    end_if;
    
    source$^void        := theOLPhaseOf[currentPhase];
    destination$^void   := theOLPhaseOf[currentPhase + 1];
    
    if source = NIL | destination = NIL then
        return;
    end_if;
    
    // This function only updates Phase 2 based on Phase 1's findings
    // If Phase 2 was found, then nothing is updated.
    // This requires "reset" to be pressed a lot. 
    // TODO: may come with update to automated step process
    // Find a better way to update without the need to reset "openLoopSuccess"

    destination^.setStartIndex(liveValues[SWITCH_TYPE_TIME] + 1);
    
    if destination^.openLoopSuccess() then
        return;
    end_if;
    
    if source^.openLoopSuccess() & !!flag_phase2Initialized then
        // This is the first time phase 2 is being updated after a phase 1 success
        flag_phase2Initialized := TRUE;
        destination^.startFeedForward       := to_dint(to_real(source^.getActualFeedForward()) * (to_real(feedForwardMultiplier) / PERCENT_DECIMAL));
    else
        // We want phase 2 to remember where phase 2 was last shot.
        destination^.startFeedForward       := destination^.getActualFeedForward();
    end_if;
    
    destination^.percentPressureLimit   := to_dint(to_real(source^.percentPressureLimit) * (to_real(pressureMultiplier) / PERCENT_DECIMAL));
    destination^.stepFeedForward        := source^.stepFeedForward;
    destination^.timeLimit              := source^.timeLimitStep + liveValues[SWITCH_TYPE_TIME];
    destination^.timeLimitStep          := source^.timeLimitStep;
    destination^.attemptsAllowed        := source^.attemptsAllowed;
    
    destination^.resetAutoActuals();
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL GainControl::testFunc::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	testFunc := input;
    
    case testFunc of
    1:
        //initializeOpenLoopAutoTune();
    end_case;

	result := testFunc;

END_FUNCTION
